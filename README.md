# 局域网聊天工具

## 分析聊天工具

* 注意：没有服务端，每一个用户都是客户端。
* 功能：上线通知、聊天、发文件、下线通知、远程监控、其他功能。
* 发文件：使用tcp协议。单独写这个功能。正常传输使用udp，文件作为另一功能最后加入。

## 架构
* 现有一个网络接口，专门负责收发数据，即网络接口iNet，有几个子类，是一个纯虚的类，纯虚函数。
	* TCP类和UDP类，TcpNet、UdpNet，即使用不到tcp传输，也要设置接口，以便以后可以使用。
	* 网络接口四种功能：初始化网络、关闭网络、收数据、发数据。
	* 接口不管是tcp还是udp都用得到。
* 类单一原则，因此也要有一个ui类。
* 要加一个核心处理类。
	* 例如，ui操作，发送到kernel类，然后把你的信号组织成一个包，然后打包发出去。
	* kernel类和ui在qt写，net在c++写，但是net和kernel需要一个桥梁，最好不要直接接触。
	* 如果直接接触，那么我的net类里面肯定是有与qt相关的操作了，这样net类就被污染了
* 因此提出：需要给net类封装，就需要一个中介者类。
* 每个人都和中介接触。mediator中介者。
	* tcpmediator和udpmediator是中介者的两个子类。
	* 因此，中介者应该与网络一样，人家有什么你中介者就也应该有什么。
* 因此对于结构：
	* kernel类是最主要的类，在qt中编写。
	* ui类和中介者类作为kernel的子类，分别在qt和c++中写。
	* 网络类和中介者类互为子类，在c++中写。

## 准备工作
* 创建了cpp之后，进入文件资源管理器
* 然后添加两个目录，net和mediator，为了方便管理
* 每个目录中手动创建cpp和头文件
* 中介者
	* INetMediator.h
	* UdpMediator.cpp
	* UdpMediator.h
* 网络接口
	* INet.h
	* UdpNet.cpp
	* UdpNet.h
* 首先子类暂时先不写udp，此时inet作为父类接口，是不需要写cpp文件的，理由就是这是一个纯虚函数。
* 添加筛选器net和mediator
	* 形如头文件、源文件、外部依赖项，均属于筛选器。用于分文别类。
	* 筛选器添加现有项，框选对应的3个文件。
* 右键项目——属性——VC++目录——包含目录——下拉编辑
	* 但是问题是，直接添加是绝对路径，我们应该要变成相对路径，要跟随项目。
	* 相对的应该是，main文件
	* 到此，可以使用创建的头文件了。

## 中介者模式(mediator)
* 设计模式的一种
	* 用一个中介者对象来封装一系列的对象交互。
	* 中介者使各个对象可以独立地改变它们之间的交互。
	* 解决多组件之间的通信问题，使得组件之间的通信变得简单。
* 关于项目里的中介者模式
	* 意义：让INet这个接口功能的实现能够复用到任何平台上，例如QT和MFC是支持c++平台的。
	* 把qt相关修改的地方都写在中介者接口里，这样移植到彼得平台的时候，只需要修改中介者接口的实现，而不需要在INet接口修改了。

## INet.h
* 接口一定是public
	* 这其中，接收数据是内部函数不会被调用，因此用保护类型。
	* 不能忘记虚析构
* 数据到手，都会转化成char*类型。
	* 实际使用的时候再进行转化。
	* 类似于udp接收文件，使用char*接收收到的内容，用int值来为空间赋大小。
* 接口的ip地址来源
	* udp用ip地址发送给对方，net接口里的ip地址是从kernel里传下来的。
	* 通过ip地址形成一个addr的一个地址。
* 目前认为，初始化init和发送send是bool返回。
* 卸载uninit和接收recv是void返回。
	* 其中，接收并没有参数，而发送有，ip地址，以及字符串存储和它的大小。

## UdpNet.h
* 首先不能忘了继承
	* 子类中的virtual就可以省略了。
	* 还得有父类头文件。
* 针对套娃类：
	* 不用加入头文件，直接声明类名即可。
	* 因为我们只是浅用一下，就不用加入头文件了，仅仅声明即可。

## c++注意事项
* 首先说接口类都一定是有virtual的，但是其子类的头文件可以不用有。
* 头文件的作用就是声明函数，要加类名作用域，然后直接分号结尾就好了。

## UdpNet.cpp
* 不仅要有声明的头文件，还要包含，中介者接口头文件。
* 构造函数中，将中介者接口指针作为参数，令网络接口的参数进行赋值。
* 而在此后的udp中介者cpp的构造函数中，直接new一个udpnet的对象，但是人家有参数啊，用this就行了。
* 小问题，在两个接口类的构造函数中，会提示未初始化类成员，也就是互相套娃的指针。

## 初始化网络
* 开始问题
	* 将udp客户端代码直接放到udpnet.cpp中。
	* 无非就是加载库、创建套接字等。
	* 也会有广播功能，顺便把广播内容也放进去。
	* 服务端的绑定ip地址功能，因为原来的客户端没有ip地址功能。
* 问题
	* 头文件，加载库，都需要的话，就需要放在父类当中。
	* 连接成功语句移除，卸载库等内容放入关闭网络功能当中。
* 套接字
	* 套接字是初始化网络必备的内容，但是关闭也一定需要，因此，要将套接字作为udpnet成员进行参数载入。
	* 而初始化就可以在构造函数的初始化列表里进行了。

## 宏定义
* 在inet中加入PackDef.h这种宏定义头文件
	* 写项目时候避免：数字，于是要进行宏定义。
	* 会有很多的宏定义，因此要进行汇总

## 线程
* createthread函数
	* 当函数中有"c++运行时库"的函数的时候，就会开辟空间，在退出线程时，不会回收空间。
	* c++运行时库，形如strcpy，有源空间和目的空间，也就是说：新创建一块空间，然后再进行操作。
	* createthread中，自己开辟的空间是不会回收的。
* _beginthreadex函数
	* 用新的函数来创建线程
	* 销毁时候，自动调用_endthreadex函数，先回收运行时库的空间，然后调用销毁。不像create与exitthread是配套的。
	* 退出线程自己调用exit或end，不用自己写。
	* end中，先回收时库的新开辟的空间，然后调用exit，这么看来就是，end包含了exit
	* 头文件<process.h>
	* 基本与create适用一致。也是用句柄接收。
	* 线程，也要在关闭网络的时候退出。因此，也要当做是成员变量。
* 线程函数
	* 不希望作为游离函数，也不能作为类内函数，因此应该设置为静态的函数成员。
	* 基于c++的封装特性，就要把他放到类里面去。
	* 模板是unsigned __stdcall，至于为什么不用WINAPI，是因为这是函数的规定。
	* 新的问题：类成员函数，必须依赖于：对象创建爱你之后，那么问题就是：封装的时候，编译器并不了解。因此应该是一个，静态成员函数。
	* 静态成员函数，不依赖对象存在而存在的。静态函数随时可用。
	* 更新的问题：静态函数不能使用其他成员函数。那么如何调用recvdata函数呢？
	* 对象可以用参数传进来，this。
	* _beginthreadex(0,0,&recvthread,this,0,0);
1:29:25